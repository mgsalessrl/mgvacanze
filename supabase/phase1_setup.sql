-- FASE 1: Database & Auth Setup

-- 1. PREPARAZIONE PROFILI & RUOLI
-- Crea tabella profiles collegata a auth.users per gestire i ruoli (admin/user)
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  role text default 'user' check (role in ('user', 'admin')),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Abilita RLS su profiles
alter table public.profiles enable row level security;

-- Policy: I profili sono visibili a tutti (o restringere se necessario)
create policy "Public profiles are viewable by everyone." on public.profiles
  for select using (true);

-- Policy: Gli utenti possono aggiornare il proprio profilo
create policy "Users can update own profile." on public.profiles
  for update using (auth.uid() = id);

-- Funzione per creare automaticamente il profilo alla registrazione
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, role)
  values (new.id, new.email, 'user'); -- Default role: user
  return new;
end;
$$ language plpgsql security definer;

-- Trigger: se non esiste, crealo
-- Nota: Supabase permette di creare trigger condizionali o bisogna distruggerlo prima.
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- 2. TABELLA PRENOTAZIONI (BOOKINGS)
-- I requisiti sono: id, property_id, user_email, start_date, end_date, total_price, status, extra_services, created_at
-- Assumiamo che la tabella 'properties' esista già (da schema precedenti).

create table if not exists public.bookings (
  id bigint generated by default as identity primary key,
  property_id bigint references public.properties(id),
  
  user_email text not null, -- Email del cliente (per comunicazioni)
  user_id uuid references auth.users(id), -- Opzionale: se l'utente è loggato
  
  start_date date not null,
  end_date date not null,
  
  total_price decimal(10, 2) not null default 0,
  
  status text default 'pending' check (status in ('pending', 'confirmed', 'paid', 'cancelled')),
  
  extra_services jsonb default '[]'::jsonb, -- Array di oggetti extra selezionati
  
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Abilita RLS su bookings
alter table public.bookings enable row level security;

-- Policy 1: Chiunque può creare una prenotazione (anche guest, se decidiamo di permetterlo)
create policy "Anyone can create a booking" 
  on public.bookings for insert 
  with check (true);

-- Policy 2: Gli utenti loggati possono vedere le proprie prenotazioni
create policy "Users can view own bookings"
  on public.bookings for select
  using ( 
    auth.uid() = user_id 
    OR 
    (auth.jwt() ->> 'email') = user_email 
  );

-- Policy 3: Gli Admin possono fare tutto
create policy "Admins can do everything on bookings"
  on public.bookings for all
  using ( 
    exists (
      select 1 from public.profiles
      where profiles.id = auth.uid()
      and profiles.role = 'admin'
    )
  );

-- Helper per gestire updated_at (opzionale ma utile)
-- (Omesse funzioni update trigger per brevità, ma status cambia spesso)
